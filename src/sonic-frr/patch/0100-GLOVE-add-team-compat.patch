Add support for teamd interfaces as bond interfaces

From: Yaroslav Fedoriachenko <y.fedoriachenko@globallogic.com>


---
 zebra/if_netlink.c |   12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/zebra/if_netlink.c b/zebra/if_netlink.c
index 7613f5fcc..83f73f9e4 100644
--- a/zebra/if_netlink.c
+++ b/zebra/if_netlink.c
@@ -230,8 +230,12 @@ static void netlink_determine_zebra_iftype(const char *kind,
 		*zif_type = ZEBRA_IF_VETH;
 	else if (strcmp(kind, "bond") == 0)
 		*zif_type = ZEBRA_IF_BOND;
+	else if (strcmp(kind, "team") == 0)
+		*zif_type = ZEBRA_IF_BOND;
 	else if (strcmp(kind, "bond_slave") == 0)
 		*zif_type = ZEBRA_IF_BOND_SLAVE;
+	else if (strcmp(kind, "team_slave") == 0)
+		*zif_type = ZEBRA_IF_BOND_SLAVE;
 	else if (strcmp(kind, "gre") == 0)
 		*zif_type = ZEBRA_IF_GRE;
 }
@@ -1519,6 +1523,8 @@ int netlink_link_change(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 
 		if ((slave_kind != NULL) && strcmp(slave_kind, "bond") == 0)
 			netlink_determine_zebra_iftype("bond_slave", &zif_type);
+		else if ((slave_kind != NULL) && strcmp(slave_kind, "team") == 0)
+			netlink_determine_zebra_iftype("team_slave", &zif_type);
 		else
 			netlink_determine_zebra_iftype(kind, &zif_type);
 	}
@@ -1591,6 +1597,12 @@ int netlink_link_change(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 				master_infindex = bond_ifindex =
 					*(ifindex_t *)RTA_DATA(tb[IFLA_MASTER]);
 				bypass = netlink_parse_lacp_bypass(linkinfo);
+			} else if (slave_kind
+				   && (strcmp(slave_kind, "team") == 0)) {
+				zif_slave_type = ZEBRA_IF_SLAVE_BOND;
+				master_infindex = bond_ifindex =
+					*(ifindex_t *)RTA_DATA(tb[IFLA_MASTER]);
+				bypass = 0;
 			} else
 				zif_slave_type = ZEBRA_IF_SLAVE_OTHER;
 		}
